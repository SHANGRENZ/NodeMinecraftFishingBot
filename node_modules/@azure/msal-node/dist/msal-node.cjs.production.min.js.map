{"version":3,"file":"msal-node.cjs.production.min.js","sources":["../src/utils/Constants.ts","../src/network/HttpClient.ts","../src/config/Configuration.ts","../src/utils/NetworkUtils.ts","../src/utils/EncodingUtils.ts","../src/crypto/PkceGenerator.ts","../src/crypto/CryptoProvider.ts","../src/crypto/GuidGenerator.ts","../src/cache/serializer/Deserializer.ts","../src/cache/serializer/Serializer.ts","../src/cache/NodeStorage.ts","../src/cache/TokenCache.ts","../src/client/ClientApplication.ts","../src/packageMetadata.ts","../src/client/ClientAssertion.ts","../src/client/ConfidentialClientApplication.ts","../src/client/PublicClientApplication.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * http methods\r\n */\r\nexport enum HttpMethod {\r\n    GET = \"get\",\r\n    POST = \"post\",\r\n}\r\n\r\n/**\r\n * Constants used for region discovery\r\n */\r\nexport const REGION_ENVIRONMENT_VARIABLE = \"REGION_NAME\";\r\n\r\n/**\r\n * Constant used for PKCE\r\n */\r\nexport const RANDOM_OCTET_SIZE = 32;\r\n\r\n/**\r\n * Constants used in PKCE\r\n */\r\nexport const Hash = {\r\n    SHA256: \"sha256\",\r\n};\r\n\r\n/**\r\n * Constants for encoding schemes\r\n */\r\nexport const CharSet = {\r\n    CV_CHARSET:\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\",\r\n};\r\n\r\n/**\r\n * Cache Constants\r\n */\r\nexport const CACHE = {\r\n    FILE_CACHE: \"fileCache\",\r\n    EXTENSION_LIB: \"extenstion_library\",\r\n};\r\n\r\n/**\r\n * Constants\r\n */\r\nexport const Constants = {\r\n    MSAL_SKU: \"msal.js.node\",\r\n    JWT_BEARER_ASSERTION_TYPE: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\r\n};\r\n\r\n/**\r\n * API Codes for Telemetry purposes.\r\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\r\n * 0-99 Silent Flow\r\n * 600-699 Device Code Flow\r\n * 800-899 Auth Code Flow\r\n */\r\nexport enum ApiId {\r\n    acquireTokenSilent = 62,\r\n    acquireTokenByUsernamePassword = 371,\r\n    acquireTokenByDeviceCode = 671,\r\n    acquireTokenByClientCredential = 771,\r\n    acquireTokenByCode = 871,\r\n    acquireTokenByRefreshToken = 872\r\n}\r\n\r\n/**\r\n * JWT  constants\r\n */\r\nexport const JwtConstants = {\r\n    ALGORITHM: \"alg\",\r\n    RSA_256: \"RS256\",\r\n    X5T: \"x5t\", \r\n    X5C: \"x5c\",\r\n    AUDIENCE: \"aud\",\r\n    EXPIRATION_TIME: \"exp\",\r\n    ISSUER: \"iss\",\r\n    SUBJECT: \"sub\",\r\n    NOT_BEFORE: \"nbf\",\r\n    JWT_ID: \"jti\",\r\n};\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    INetworkModule,\r\n    NetworkRequestOptions,\r\n    NetworkResponse,\r\n} from \"@azure/msal-common\";\r\nimport { HttpMethod } from \"../utils/Constants\";\r\nimport axios, { AxiosRequestConfig } from \"axios\";\r\n\r\n/**\r\n * This class implements the API for network requests.\r\n */\r\nexport class HttpClient implements INetworkModule {\r\n\r\n    /**\r\n     * Http Get request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendGetRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.GET,\r\n            url: url,\r\n            headers: options && options.headers,\r\n            validateStatus: () => true\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Http Post request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendPostRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions,\r\n        cancellationToken?: number \r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.POST,\r\n            url: url,\r\n            data: (options && options.body) || \"\",\r\n            timeout: cancellationToken,\r\n            headers: options && options.headers,\r\n            validateStatus: () => true\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    LoggerOptions,\r\n    INetworkModule,\r\n    LogLevel,\r\n    ProtocolMode,\r\n    ICachePlugin, Constants\r\n} from \"@azure/msal-common\";\r\nimport { NetworkUtils } from \"../utils/NetworkUtils\";\r\n\r\n/**\r\n * - clientId               - Client id of the application.\r\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\r\n * - knownAuthorities       - Needed for Azure B2C and ADFS. All authorities that will be used in the client application. Only the host of the authority should be passed in.\r\n * - clientSecret           - Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal.\r\n * - clientAssertion        - Assertion string that the application uses when requesting a token. Only used in confidential client applications. Assertion should be of type urn:ietf:params:oauth:client-assertion-type:jwt-bearer.\r\n * - clientCertificate      - Certificate that the application uses when requesting a token. Only used in confidential client applications. Requires hex encoded X.509 SHA-1 thumbprint of the certificiate, and the PEM encoded private key (string should contain -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- )\r\n * - protocolMode           - Enum that represents the protocol that msal follows. Used for configuring proper endpoints.\r\n * @public\r\n */\r\nexport type NodeAuthOptions = {\r\n    clientId: string;\r\n    authority?: string;\r\n    clientSecret?: string;\r\n    clientAssertion?:string;\r\n    clientCertificate?: {\r\n        thumbprint: string,\r\n        privateKey: string,\r\n        x5c?: string\r\n    };\r\n    knownAuthorities?: Array<string>;\r\n    cloudDiscoveryMetadata?: string;\r\n    authorityMetadata?: string,\r\n    clientCapabilities?: [];\r\n    protocolMode?: ProtocolMode;\r\n};\r\n\r\n/**\r\n * Use this to configure the below cache configuration options:\r\n *\r\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\r\n * @public\r\n */\r\nexport type CacheOptions = {\r\n    cachePlugin?: ICachePlugin;\r\n};\r\n\r\n/**\r\n * Type for configuring logger and http client options\r\n *\r\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\r\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\r\n * @public\r\n */\r\nexport type NodeSystemOptions = {\r\n    loggerOptions?: LoggerOptions;\r\n    networkClient?: INetworkModule;\r\n};\r\n\r\n/**\r\n * Use the configuration object to configure MSAL and initialize the client application object\r\n *\r\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\r\n * - cache: this is where you configure cache location\r\n * - system: this is where you can configure the network client, logger\r\n * @public\r\n */\r\nexport type Configuration = {\r\n    auth: NodeAuthOptions;\r\n    cache?: CacheOptions;\r\n    system?: NodeSystemOptions;\r\n};\r\n\r\nconst DEFAULT_AUTH_OPTIONS: NodeAuthOptions = {\r\n    clientId: \"\",\r\n    authority: Constants.DEFAULT_AUTHORITY,\r\n    clientSecret: \"\",\r\n    clientAssertion: \"\",\r\n    clientCertificate: {\r\n        thumbprint: \"\",\r\n        privateKey: \"\",\r\n        x5c: \"\"\r\n    },\r\n    knownAuthorities: [],\r\n    cloudDiscoveryMetadata: \"\",\r\n    authorityMetadata: \"\",\r\n    clientCapabilities: [],\r\n    protocolMode: ProtocolMode.AAD\r\n};\r\n\r\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {};\r\n\r\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\r\n    loggerCallback: (): void => {\r\n        // allow users to not set logger call back\r\n    },\r\n    piiLoggingEnabled: false,\r\n    logLevel: LogLevel.Info,\r\n};\r\n\r\nconst DEFAULT_SYSTEM_OPTIONS: NodeSystemOptions = {\r\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\r\n    networkClient: NetworkUtils.getNetworkClient(),\r\n};\r\n\r\n/**\r\n * Sets the default options when not explicitly configured from app developer\r\n *\r\n * @param auth - Authentication options\r\n * @param cache - Cache options\r\n * @param system - System options\r\n *\r\n * @returns Configuration\r\n * @public\r\n */\r\nexport function buildAppConfiguration({\r\n    auth,\r\n    cache,\r\n    system,\r\n}: Configuration): Configuration {\r\n    return {\r\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\r\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\r\n        system: { ...DEFAULT_SYSTEM_OPTIONS, ...system },\r\n    };\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from \"@azure/msal-common\";\r\nimport { HttpClient } from \"../network/HttpClient\";\r\n\r\nexport class NetworkUtils {\r\n    /**\r\n     * Returns best compatible network client object.\r\n     */\r\n    static getNetworkClient(): INetworkModule {\r\n        return new HttpClient();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nexport class EncodingUtils {\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param str text\r\n     */\r\n    static base64Encode(str: string, encoding?: BufferEncoding): string {\r\n        return Buffer.from(str, encoding).toString(\"base64\");\r\n    }\r\n\r\n    /**\r\n     * encode a URL\r\n     * @param str\r\n     */\r\n    static base64EncodeUrl(str: string, encoding?: BufferEncoding): string {\r\n        return EncodingUtils.base64Encode(str, encoding)\r\n            .replace(/=/g, \"\")\r\n            .replace(/\\+/g, \"-\")\r\n            .replace(/\\//g, \"_\");\r\n    }\r\n\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param base64Str Base64 encoded text\r\n     */\r\n    static base64Decode(base64Str: string): string {\r\n        return Buffer.from(base64Str, \"base64\").toString(\"utf8\");\r\n    }\r\n\r\n    /**\r\n     * @param base64Str Base64 encoded Url\r\n     */\r\n    static base64DecodeUrl(base64Str: string): string {\r\n        let str = base64Str.replace(/-/g, \"+\").replace(/_/g, \"/\");\r\n        while (str.length % 4) {\r\n            str += \"=\";\r\n        }\r\n        return EncodingUtils.base64Decode(str);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { PkceCodes } from \"@azure/msal-common\";\r\nimport { CharSet, Hash, RANDOM_OCTET_SIZE } from \"../utils/Constants\";\r\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\r\nimport crypto from \"crypto\";\r\n\r\n/**\r\n * https://tools.ietf.org/html/rfc7636#page-8\r\n */\r\nexport class PkceGenerator {\r\n    /**\r\n     * generates the codeVerfier and the challenge from the codeVerfier\r\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\r\n     */\r\n    async generatePkceCodes(): Promise<PkceCodes> {\r\n        const verifier = this.generateCodeVerifier();\r\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\r\n        return { verifier, challenge };\r\n    }\r\n\r\n    /**\r\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     */\r\n    private generateCodeVerifier(): string {\r\n        const buffer: Uint8Array = crypto.randomBytes(RANDOM_OCTET_SIZE);\r\n        const verifier: string = this.bufferToCVString(buffer);\r\n        return EncodingUtils.base64EncodeUrl(verifier);\r\n    }\r\n\r\n    /**\r\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\r\n     * @param codeVerifier\r\n     */\r\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\r\n        return EncodingUtils.base64EncodeUrl(\r\n            this.sha256(codeVerifier).toString(\"base64\"), \r\n            \"base64\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * generate 'SHA256' hash\r\n     * @param buffer\r\n     */\r\n    private sha256(buffer: string): Buffer {\r\n        return crypto\r\n            .createHash(Hash.SHA256)\r\n            .update(buffer)\r\n            .digest();\r\n    }\r\n\r\n    /**\r\n     * Accepted characters; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     * @param buffer\r\n     */\r\n    private bufferToCVString(buffer: Uint8Array): string {\r\n        const charArr = [];\r\n        for (let i = 0; i < buffer.byteLength; i += 1) {\r\n            const index = buffer[i] % CharSet.CV_CHARSET.length;\r\n            charArr.push(CharSet.CV_CHARSET[index]);\r\n        }\r\n        return charArr.join(\"\");\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ICrypto, PkceCodes } from \"@azure/msal-common\";\r\nimport { GuidGenerator } from \"./GuidGenerator\";\r\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\r\nimport { PkceGenerator } from \"./PkceGenerator\";\r\n\r\n/**\r\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n * @public\r\n */\r\nexport class CryptoProvider implements ICrypto {\r\n    private pkceGenerator: PkceGenerator;\r\n\r\n    constructor() {\r\n        // Browser crypto needs to be validated first before any other classes can be set.\r\n        this.pkceGenerator = new PkceGenerator();\r\n    }\r\n\r\n    /**\r\n     * Creates a new random GUID - used to populate state and nonce.\r\n     * @returns string (GUID)\r\n     */\r\n    createNewGuid(): string {\r\n        return GuidGenerator.generateGuid();\r\n    }\r\n\r\n    /**\r\n     * Encodes input string to base64.\r\n     * @param input - string to be encoded\r\n     */\r\n    base64Encode(input: string): string {\r\n        return EncodingUtils.base64Encode(input);\r\n    }\r\n\r\n    /**\r\n     * Decodes input string from base64.\r\n     * @param input - string to be decoded\r\n     */\r\n    base64Decode(input: string): string {\r\n        return EncodingUtils.base64Decode(input);\r\n    }\r\n\r\n    /**\r\n     * Generates PKCE codes used in Authorization Code Flow.\r\n     */\r\n    generatePkceCodes(): Promise<PkceCodes> {\r\n        return this.pkceGenerator.generatePkceCodes();\r\n    }\r\n\r\n    /**\r\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\r\n     */\r\n    getPublicKeyThumbprint(): Promise<string> {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\r\n     */\r\n    signJwt(): Promise<string> {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\nexport class GuidGenerator {\r\n    /**\r\n     *\r\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\r\n     * uuidv4 generates guids from cryprtographically-string random\r\n     */\r\n    static generateGuid(): string {\r\n        return uuidv4();\r\n    }\r\n\r\n    /**\r\n     * verifies if a string is  GUID\r\n     * @param guid\r\n     */\r\n    static isGuid(guid: string): boolean {\r\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n        return regexGuid.test(guid);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { StringUtils, AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager } from \"@azure/msal-common\";\r\nimport { JsonCache, InMemoryCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\r\n\r\n/**\r\n * This class deserializes cache entities read from the file into in memory object types defined internally\r\n */\r\nexport class Deserializer {\r\n    /**\r\n     * Parse the JSON blob in memory and deserialize the content\r\n     * @param cachedJson\r\n     */\r\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\r\n        const deserializedCache = StringUtils.isEmpty(jsonFile)\r\n            ? {}\r\n            : JSON.parse(jsonFile);\r\n        return deserializedCache;\r\n    }\r\n\r\n    /**\r\n     * Deserializes accounts to AccountEntity objects\r\n     * @param accounts\r\n     */\r\n    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache {\r\n        const accountObjects: AccountCache = {};\r\n        if (accounts) {\r\n            Object.keys(accounts).map(function (key) {\r\n                const serializedAcc = accounts[key];\r\n                const mappedAcc = {\r\n                    homeAccountId: serializedAcc.home_account_id,\r\n                    environment: serializedAcc.environment,\r\n                    realm: serializedAcc.realm,\r\n                    localAccountId: serializedAcc.local_account_id,\r\n                    username: serializedAcc.username,\r\n                    authorityType: serializedAcc.authority_type,\r\n                    name: serializedAcc.name,\r\n                    clientInfo: serializedAcc.client_info,\r\n                    lastModificationTime: serializedAcc.last_modification_time,\r\n                    lastModificationApp: serializedAcc.last_modification_app,\r\n                };\r\n                const account: AccountEntity = new AccountEntity();\r\n                CacheManager.toObject(account, mappedAcc);\r\n                accountObjects[key] = account;\r\n            });\r\n        }\r\n\r\n        return accountObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes id tokens to IdTokenEntity objects\r\n     * @param idTokens\r\n     */\r\n    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache {\r\n        const idObjects: IdTokenCache = {};\r\n        if (idTokens) {\r\n            Object.keys(idTokens).map(function (key) {\r\n                const serializedIdT = idTokens[key];\r\n                const mappedIdT = {\r\n                    homeAccountId: serializedIdT.home_account_id,\r\n                    environment: serializedIdT.environment,\r\n                    credentialType: serializedIdT.credential_type,\r\n                    clientId: serializedIdT.client_id,\r\n                    secret: serializedIdT.secret,\r\n                    realm: serializedIdT.realm,\r\n                };\r\n                const idToken: IdTokenEntity = new IdTokenEntity();\r\n                CacheManager.toObject(idToken, mappedIdT);\r\n                idObjects[key] = idToken;\r\n            });\r\n        }\r\n        return idObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes access tokens to AccessTokenEntity objects\r\n     * @param accessTokens\r\n     */\r\n    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache {\r\n        const atObjects: AccessTokenCache = {};\r\n        if (accessTokens) {\r\n            Object.keys(accessTokens).map(function (key) {\r\n                const serializedAT = accessTokens[key];\r\n                const mappedAT = {\r\n                    homeAccountId: serializedAT.home_account_id,\r\n                    environment: serializedAT.environment,\r\n                    credentialType: serializedAT.credential_type,\r\n                    clientId: serializedAT.client_id,\r\n                    secret: serializedAT.secret,\r\n                    realm: serializedAT.realm,\r\n                    target: serializedAT.target,\r\n                    cachedAt: serializedAT.cached_at,\r\n                    expiresOn: serializedAT.expires_on,\r\n                    extendedExpiresOn: serializedAT.extended_expires_on,\r\n                    refreshOn: serializedAT.refresh_on,\r\n                    keyId: serializedAT.key_id,\r\n                    tokenType: serializedAT.token_type,\r\n                };\r\n                const accessToken: AccessTokenEntity = new AccessTokenEntity();\r\n                CacheManager.toObject(accessToken, mappedAT);\r\n                atObjects[key] = accessToken;\r\n            });\r\n        }\r\n\r\n        return atObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes refresh tokens to RefreshTokenEntity objects\r\n     * @param refreshTokens\r\n     */\r\n    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache {\r\n        const rtObjects: RefreshTokenCache = {};\r\n        if (refreshTokens) {\r\n            Object.keys(refreshTokens).map(function (key) {\r\n                const serializedRT = refreshTokens[key];\r\n                const mappedRT = {\r\n                    homeAccountId: serializedRT.home_account_id,\r\n                    environment: serializedRT.environment,\r\n                    credentialType: serializedRT.credential_type,\r\n                    clientId: serializedRT.client_id,\r\n                    secret: serializedRT.secret,\r\n                    familyId: serializedRT.family_id,\r\n                    target: serializedRT.target,\r\n                    realm: serializedRT.realm,\r\n                };\r\n                const refreshToken: RefreshTokenEntity = new RefreshTokenEntity();\r\n                CacheManager.toObject(refreshToken, mappedRT);\r\n                rtObjects[key] = refreshToken;\r\n            });\r\n        }\r\n\r\n        return rtObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes appMetadata to AppMetaData objects\r\n     * @param appMetadata\r\n     */\r\n    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache {\r\n        const appMetadataObjects: AppMetadataCache = {};\r\n        if (appMetadata) {\r\n            Object.keys(appMetadata).map(function (key) {\r\n                const serializedAmdt = appMetadata[key];\r\n                const mappedAmd = {\r\n                    clientId: serializedAmdt.client_id,\r\n                    environment: serializedAmdt.environment,\r\n                    familyId: serializedAmdt.family_id,\r\n                };\r\n                const amd: AppMetadataEntity = new AppMetadataEntity();\r\n                CacheManager.toObject(amd, mappedAmd);\r\n                appMetadataObjects[key] = amd;\r\n            });\r\n        }\r\n\r\n        return appMetadataObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserialize an inMemory Cache\r\n     * @param jsonCache\r\n     */\r\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\r\n        return {\r\n            accounts: jsonCache.Account\r\n                ? this.deserializeAccounts(jsonCache.Account)\r\n                : {},\r\n            idTokens: jsonCache.IdToken\r\n                ? this.deserializeIdTokens(jsonCache.IdToken)\r\n                : {},\r\n            accessTokens: jsonCache.AccessToken\r\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\r\n                : {},\r\n            refreshTokens: jsonCache.RefreshToken\r\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\r\n                : {},\r\n            appMetadata: jsonCache.AppMetadata\r\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\r\n                : {},\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache } from \"@azure/msal-common\";\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\r\n\r\nexport class Serializer {\r\n    /**\r\n     * serialize the JSON blob\r\n     * @param data\r\n     */\r\n    static serializeJSONBlob(data: JsonCache): string {\r\n        return JSON.stringify(data);\r\n    }\r\n\r\n    /**\r\n     * Serialize Accounts\r\n     * @param accCache\r\n     */\r\n    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity> {\r\n        const accounts: Record<string, SerializedAccountEntity> = {};\r\n        Object.keys(accCache).map(function (key) {\r\n            const accountEntity = accCache[key];\r\n            accounts[key] = {\r\n                home_account_id: accountEntity.homeAccountId,\r\n                environment: accountEntity.environment,\r\n                realm: accountEntity.realm,\r\n                local_account_id: accountEntity.localAccountId,\r\n                username: accountEntity.username,\r\n                authority_type: accountEntity.authorityType,\r\n                name: accountEntity.name,\r\n                client_info: accountEntity.clientInfo,\r\n                last_modification_time: accountEntity.lastModificationTime,\r\n                last_modification_app: accountEntity.lastModificationApp,\r\n            };\r\n        });\r\n\r\n        return accounts;\r\n    }\r\n\r\n    /**\r\n     * Serialize IdTokens\r\n     * @param idTCache\r\n     */\r\n    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity> {\r\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\r\n        Object.keys(idTCache).map(function (key) {\r\n            const idTEntity = idTCache[key];\r\n            idTokens[key] = {\r\n                home_account_id: idTEntity.homeAccountId,\r\n                environment: idTEntity.environment,\r\n                credential_type: idTEntity.credentialType,\r\n                client_id: idTEntity.clientId,\r\n                secret: idTEntity.secret,\r\n                realm: idTEntity.realm,\r\n            };\r\n        });\r\n\r\n        return idTokens;\r\n    }\r\n\r\n    /**\r\n     * Serializes AccessTokens\r\n     * @param atCache\r\n     */\r\n    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity> {\r\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\r\n        Object.keys(atCache).map(function (key) {\r\n            const atEntity = atCache[key];\r\n            accessTokens[key] = {\r\n                home_account_id: atEntity.homeAccountId,\r\n                environment: atEntity.environment,\r\n                credential_type: atEntity.credentialType,\r\n                client_id: atEntity.clientId,\r\n                secret: atEntity.secret,\r\n                realm: atEntity.realm,\r\n                target: atEntity.target,\r\n                cached_at: atEntity.cachedAt,\r\n                expires_on: atEntity.expiresOn,\r\n                extended_expires_on: atEntity.extendedExpiresOn,\r\n                refresh_on: atEntity.refreshOn,\r\n                key_id: atEntity.keyId,\r\n                token_type: atEntity.tokenType,\r\n            };\r\n        });\r\n\r\n        return accessTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize refreshTokens\r\n     * @param rtCache\r\n     */\r\n    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity> {\r\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\r\n        Object.keys(rtCache).map(function (key) {\r\n            const rtEntity = rtCache[key];\r\n            refreshTokens[key] = {\r\n                home_account_id: rtEntity.homeAccountId,\r\n                environment: rtEntity.environment,\r\n                credential_type: rtEntity.credentialType,\r\n                client_id: rtEntity.clientId,\r\n                secret: rtEntity.secret,\r\n                family_id: rtEntity.familyId,\r\n                target: rtEntity.target,\r\n                realm: rtEntity.realm\r\n            };\r\n        });\r\n\r\n        return refreshTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize amdtCache\r\n     * @param amdtCache\r\n     */\r\n    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity> {\r\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\r\n        Object.keys(amdtCache).map(function (key) {\r\n            const amdtEntity = amdtCache[key];\r\n            appMetadata[key] = {\r\n                client_id: amdtEntity.clientId,\r\n                environment: amdtEntity.environment,\r\n                family_id: amdtEntity.familyId,\r\n            };\r\n        });\r\n\r\n        return appMetadata;\r\n    }\r\n\r\n    /**\r\n     * Serialize the cache\r\n     * @param jsonContent\r\n     */\r\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\r\n        return {\r\n            Account: this.serializeAccounts(inMemCache.accounts),\r\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\r\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\r\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\r\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AccountEntity,\r\n    IdTokenEntity,\r\n    AccessTokenEntity,\r\n    RefreshTokenEntity,\r\n    AppMetadataEntity,\r\n    ServerTelemetryEntity,\r\n    ThrottlingEntity,\r\n    CacheManager,\r\n    Logger,\r\n    ValidCacheType,\r\n    ICrypto,\r\n    AuthorityMetadataEntity\r\n} from \"@azure/msal-common\";\r\nimport { Deserializer } from \"./serializer/Deserializer\";\r\nimport { Serializer } from \"./serializer/Serializer\";\r\nimport { InMemoryCache, JsonCache, CacheKVStore } from \"./serializer/SerializerTypes\";\r\n\r\n/**\r\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\r\n * @public\r\n */\r\nexport class NodeStorage extends CacheManager {\r\n    // Cache configuration, either set by user or default values.\r\n    private logger: Logger;\r\n    private cache: CacheKVStore = {};\r\n    private changeEmitters: Array<Function> = [];\r\n\r\n    constructor(logger: Logger, clientId: string, cryptoImpl: ICrypto) {\r\n        super(clientId, cryptoImpl);\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Queue up callbacks\r\n     * @param func - a callback function for cache change indication\r\n     */\r\n    registerChangeEmitter(func: () => void): void {\r\n        this.changeEmitters.push(func);\r\n    }\r\n\r\n    /**\r\n     * Invoke the callback when cache changes\r\n     */\r\n    emitChange(): void {\r\n        this.changeEmitters.forEach(func => func.call(null));\r\n    }\r\n\r\n    /**\r\n     * Converts cacheKVStore to InMemoryCache\r\n     * @param cache - key value store\r\n     */\r\n    cacheToInMemoryCache(cache: CacheKVStore): InMemoryCache {\r\n\r\n        const inMemoryCache: InMemoryCache = {\r\n            accounts: {},\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {},\r\n            appMetadata: {},\r\n        };\r\n\r\n        for (const key in cache) {\r\n            if (cache[key as string] instanceof AccountEntity) {\r\n                inMemoryCache.accounts[key] = cache[key] as AccountEntity;\r\n            } else if (cache[key] instanceof IdTokenEntity) {\r\n                inMemoryCache.idTokens[key] = cache[key] as IdTokenEntity;\r\n            } else if (cache[key] instanceof AccessTokenEntity) {\r\n                inMemoryCache.accessTokens[key] = cache[key] as AccessTokenEntity;\r\n            } else if (cache[key] instanceof RefreshTokenEntity) {\r\n                inMemoryCache.refreshTokens[key] = cache[key] as RefreshTokenEntity;\r\n            } else if (cache[key] instanceof AppMetadataEntity) {\r\n                inMemoryCache.appMetadata[key] = cache[key] as AppMetadataEntity;\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n\r\n        return inMemoryCache;\r\n    }\r\n\r\n    /**\r\n     * converts inMemoryCache to CacheKVStore\r\n     * @param inMemoryCache - kvstore map for inmemory\r\n     */\r\n    inMemoryCacheToCache(inMemoryCache: InMemoryCache): CacheKVStore {\r\n        // convert in memory cache to a flat Key-Value map\r\n        let cache = this.getCache();\r\n\r\n        cache = {\r\n            ...inMemoryCache.accounts,\r\n            ...inMemoryCache.idTokens,\r\n            ...inMemoryCache.accessTokens,\r\n            ...inMemoryCache.refreshTokens,\r\n            ...inMemoryCache.appMetadata\r\n        };\r\n        return cache;\r\n    }\r\n\r\n    /**\r\n     * gets the current in memory cache for the client\r\n     */\r\n    getInMemoryCache(): InMemoryCache {\r\n        this.logger.verbose(\"Getting in-memory cache\");\r\n\r\n        // convert the cache key value store to inMemoryCache\r\n        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());\r\n        return inMemoryCache;\r\n    }\r\n\r\n    /**\r\n     * sets the current in memory cache for the client\r\n     * @param inMemoryCache - key value map in memory\r\n     */\r\n    setInMemoryCache(inMemoryCache: InMemoryCache): void{\r\n        this.logger.verbose(\"Setting in-memory cache\");\r\n\r\n        // convert and append the inMemoryCache to cacheKVStore\r\n        const cache = this.inMemoryCacheToCache(inMemoryCache);\r\n        this.setCache(cache);\r\n\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * get the current cache key-value store\r\n     */\r\n    getCache(): CacheKVStore {\r\n        this.logger.verbose(\"Getting cache key-value store\");\r\n        return this.cache;\r\n    }\r\n\r\n    /**\r\n     * sets the current cache (key value store)\r\n     * @param cacheMap - key value map\r\n     */\r\n    setCache(cache: CacheKVStore): void {\r\n        this.logger.verbose(\"Setting cache key value store\");\r\n        this.cache = cache;\r\n\r\n        // mark change in cache\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * @param key - lookup key for the cache entry\r\n     */\r\n    getItem(key: string): ValidCacheType {\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n\r\n        // read cache\r\n        const cache = this.getCache();\r\n        return cache[key];\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key-value\r\n     * @param key - lookup key for the cache entry\r\n     * @param value - value of the cache entry\r\n     */\r\n    setItem(key: string, value: ValidCacheType): void {\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n\r\n        // read cache\r\n        const cache = this.getCache();\r\n        cache[key] = value;\r\n\r\n        // write to cache\r\n        this.setCache(cache);\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity\r\n     * @param accountKey - lookup key to fetch cache type AccountEntity\r\n     */\r\n    getAccount(accountKey: string): AccountEntity | null {\r\n        const account = this.getItem(accountKey) as AccountEntity;\r\n        if (AccountEntity.isAccountEntity(account)) {\r\n            return account;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set account entity\r\n     * @param account - cache value to be set of type AccountEntity\r\n     */\r\n    setAccount(account: AccountEntity): void {\r\n        const accountKey = account.generateAccountKey();\r\n        this.setItem(accountKey, account);\r\n    }\r\n\r\n    /**\r\n     * fetch the idToken credential\r\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\r\n     */\r\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\r\n        const idToken = this.getItem(idTokenKey) as IdTokenEntity;\r\n        if (IdTokenEntity.isIdTokenEntity(idToken)) {\r\n            return idToken;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set idToken credential\r\n     * @param idToken - cache value to be set of type IdTokenEntity\r\n     */\r\n    setIdTokenCredential(idToken: IdTokenEntity): void {\r\n        const idTokenKey = idToken.generateCredentialKey();\r\n        this.setItem(idTokenKey, idToken);\r\n    }\r\n\r\n    /**\r\n     * fetch the accessToken credential\r\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\r\n     */\r\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\r\n        const accessToken = this.getItem(accessTokenKey) as AccessTokenEntity;\r\n        if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {\r\n            return accessToken;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set accessToken credential\r\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\r\n     */\r\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\r\n        const accessTokenKey = accessToken.generateCredentialKey();\r\n        this.setItem(accessTokenKey, accessToken);\r\n    }\r\n\r\n    /**\r\n     * fetch the refreshToken credential\r\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\r\n     */\r\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\r\n        const refreshToken = this.getItem(refreshTokenKey) as RefreshTokenEntity;\r\n        if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {\r\n            return refreshToken as RefreshTokenEntity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set refreshToken credential\r\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\r\n     */\r\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\r\n        const refreshTokenKey = refreshToken.generateCredentialKey();\r\n        this.setItem(refreshTokenKey, refreshToken);\r\n    }\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\r\n     */\r\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\r\n        const appMetadata: AppMetadataEntity = this.getItem(appMetadataKey) as AppMetadataEntity;\r\n        if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {\r\n            return appMetadata;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\r\n     */\r\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\r\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\r\n        this.setItem(appMetadataKey, appMetadata);\r\n    }\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\r\n     */\r\n    getServerTelemetry(serverTelemetrykey: string): ServerTelemetryEntity | null {\r\n        const serverTelemetryEntity: ServerTelemetryEntity = this.getItem(serverTelemetrykey) as ServerTelemetryEntity;\r\n        if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {\r\n            return serverTelemetryEntity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\r\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\r\n     */\r\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\r\n        this.setItem(serverTelemetryKey, serverTelemetry);\r\n    }\r\n\r\n    /**\r\n     * fetch authority metadata entity from the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     */\r\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\r\n        const authorityMetadataEntity: AuthorityMetadataEntity = this.getItem(key) as AuthorityMetadataEntity;\r\n        if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {\r\n            return authorityMetadataEntity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all authority metadata keys\r\n     */\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        return this.getKeys().filter((key) => {\r\n            return this.isAuthorityMetadata(key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * set authority metadata entity to the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\r\n     */\r\n    setAuthorityMetadata(key: string, metadata: AuthorityMetadataEntity): void {\r\n        this.setItem(key, metadata);\r\n    }\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     */\r\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\r\n        const throttlingCache: ThrottlingEntity = this.getItem(throttlingCacheKey) as ThrottlingEntity;\r\n        if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {\r\n            return throttlingCache;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\r\n     */\r\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\r\n        this.setItem(throttlingCacheKey, throttlingCache);\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item from memory with the given key.\r\n     * @param key - lookup key to remove a cache entity\r\n     * @param inMemory - key value map of the cache\r\n     */\r\n    removeItem(key: string): boolean {\r\n        this.logger.verbosePii(`Item key: ${key}`);\r\n\r\n        // read inMemoryCache\r\n        let result: boolean = false;\r\n        const cache = this.getCache();\r\n\r\n        if (!!cache[key]) {\r\n            delete cache[key];\r\n            result = true;\r\n        }\r\n\r\n        // write to the cache after removal\r\n        if (result) {\r\n            this.setCache(cache);\r\n            this.emitChange();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key - look up key for a cache entity\r\n     */\r\n    containsKey(key: string): boolean {\r\n        return this.getKeys().includes(key);\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        this.logger.verbose(\"Retrieving all cache keys\");\r\n\r\n        // read cache\r\n        const cache = this.getCache();\r\n        return [ ...Object.keys(cache)];\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\r\n    clear(): void {\r\n        this.logger.verbose(\"Clearing cache entries created by MSAL\");\r\n\r\n        // read inMemoryCache\r\n        const cacheKeys = this.getKeys();\r\n\r\n        // delete each element\r\n        cacheKeys.forEach(key => {\r\n            this.removeItem(key);\r\n        });\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Initialize in memory cache from an exisiting cache vault\r\n     * @param cache - blob formatted cache (JSON)\r\n     */\r\n    static generateInMemoryCache(cache: string): InMemoryCache {\r\n        return Deserializer.deserializeAllCache(\r\n            Deserializer.deserializeJSONBlob(cache)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * retrieves the final JSON\r\n     * @param inMemoryCache - itemised cache read from the JSON\r\n     */\r\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\r\n        return Serializer.serializeAllCache(inMemoryCache);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { NodeStorage } from \"./NodeStorage\";\r\nimport { StringUtils, AccountEntity, AccountInfo, Logger, ISerializableTokenCache, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedIdTokenEntity, SerializedAppMetadataEntity, CacheKVStore } from \"./serializer/SerializerTypes\";\r\nimport { Deserializer } from \"./serializer/Deserializer\";\r\nimport { Serializer } from \"./serializer/Serializer\";\r\nimport { ITokenCache } from \"./ITokenCache\";\r\n\r\nconst defaultSerializedCache: JsonCache = {\r\n    Account: {},\r\n    IdToken: {},\r\n    AccessToken: {},\r\n    RefreshToken: {},\r\n    AppMetadata: {},\r\n};\r\n\r\n/**\r\n * In-memory token cache manager\r\n * @public\r\n */\r\nexport class TokenCache implements ISerializableTokenCache, ITokenCache {\r\n\r\n    private storage: NodeStorage;\r\n    private cacheHasChanged: boolean;\r\n    private cacheSnapshot: string;\r\n    private readonly persistence: ICachePlugin;\r\n    private logger: Logger;\r\n\r\n    constructor(storage: NodeStorage, logger: Logger, cachePlugin?: ICachePlugin) {\r\n        this.cacheHasChanged = false;\r\n        this.storage = storage;\r\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\r\n        if (cachePlugin) {\r\n            this.persistence = cachePlugin;\r\n        }\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Set to true if cache state has changed since last time serialize or writeToPersistence was called\r\n     */\r\n    hasChanged(): boolean {\r\n        return this.cacheHasChanged;\r\n    }\r\n\r\n    /**\r\n     * Serializes in memory cache to JSON\r\n     */\r\n    serialize(): string {\r\n        this.logger.verbose(\"Serializing in-memory cache\");\r\n        let finalState = Serializer.serializeAllCache(\r\n            this.storage.getInMemoryCache() as InMemoryCache\r\n        );\r\n\r\n        // if cacheSnapshot not null or empty, merge\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.verbose(\"Reading cache snapshot from disk\");\r\n            finalState = this.mergeState(\r\n                JSON.parse(this.cacheSnapshot),\r\n                finalState\r\n            );\r\n        } else {\r\n            this.logger.verbose(\"No cache snapshot to merge\");\r\n        }\r\n        this.cacheHasChanged = false;\r\n\r\n        return JSON.stringify(finalState);\r\n    }\r\n\r\n    /**\r\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\r\n     * @param cache - blob formatted cache\r\n     */\r\n    deserialize(cache: string): void {\r\n        this.logger.verbose(\"Deserializing JSON to in-memory cache\");\r\n        this.cacheSnapshot = cache;\r\n\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.verbose(\"Reading cache snapshot from disk\");\r\n            const deserializedCache = Deserializer.deserializeAllCache(\r\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\r\n            );\r\n            this.storage.setInMemoryCache(deserializedCache);\r\n        } else {\r\n            this.logger.verbose(\"No cache snapshot to deserialize\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetches the cache key-value map\r\n     */\r\n    getKVStore(): CacheKVStore {\r\n        return this.storage.getCache();\r\n    }\r\n\r\n    /**\r\n     * API that retrieves all accounts currently in cache to the user\r\n     */\r\n    async getAllAccounts(): Promise<AccountInfo[]> {\r\n\r\n        this.logger.verbose(\"getAllAccounts called\");\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistence) {\r\n                cacheContext = new TokenCacheContext(this, false);\r\n                await this.persistence.beforeCacheAccess(cacheContext);\r\n            }\r\n            return this.storage.getAllAccounts();\r\n        } finally {\r\n            if (this.persistence && cacheContext) {\r\n                await this.persistence.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching homeAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param homeAccountId - unique identifier for an account (uid.utid)\r\n     */\r\n    async getAccountByHomeId(homeAccountId: string): Promise<AccountInfo | null> {\r\n        const allAccounts = await this.getAllAccounts();\r\n        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\r\n            return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching localAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\r\n     */\r\n    async getAccountByLocalId(localAccountId: string): Promise<AccountInfo | null> {\r\n        const allAccounts = await this.getAllAccounts();\r\n        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\r\n            return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * API to remove a specific account and the relevant data from cache\r\n     * @param account - AccountInfo passed by the user\r\n     */\r\n    async removeAccount(account: AccountInfo): Promise<void> {\r\n        this.logger.verbose(\"removeAccount called\");\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistence) {\r\n                cacheContext = new TokenCacheContext(this, true);\r\n                await this.persistence.beforeCacheAccess(cacheContext);\r\n            }\r\n            this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));\r\n        } finally {\r\n            if (this.persistence && cacheContext) {\r\n                await this.persistence.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the cache has changed state.\r\n     */\r\n    private handleChangeEvent() {\r\n        this.cacheHasChanged = true;\r\n    }\r\n\r\n    /**\r\n     * Merge in memory cache with the cache snapshot.\r\n     * @param oldState - cache before changes\r\n     * @param currentState - current cache state in the library\r\n     */\r\n    private mergeState(oldState: JsonCache, currentState: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Merging in-memory cache with cache snapshot\");\r\n        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);\r\n        return this.mergeUpdates(stateAfterRemoval, currentState);\r\n    }\r\n\r\n    /**\r\n     * Deep update of oldState based on newState values\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    private mergeUpdates(oldState: object, newState: object): JsonCache {\r\n        Object.keys(newState).forEach((newKey: string) => {\r\n            const newValue = newState[newKey];\r\n\r\n            // if oldState does not contain value but newValue does, add it\r\n            if (!oldState.hasOwnProperty(newKey)) {\r\n                if (newValue !== null) {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            } else {\r\n                // both oldState and newState contain the key, do deep update\r\n                const newValueNotNull = newValue !== null;\r\n                const newValueIsObject = typeof newValue === \"object\";\r\n                const newValueIsNotArray = !Array.isArray(newValue);\r\n                const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== \"undefined\" && oldState[newKey] !== null;\r\n\r\n                if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {\r\n                    this.mergeUpdates(oldState[newKey], newValue);\r\n                } else {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            }\r\n        });\r\n\r\n        return oldState as JsonCache;\r\n    }\r\n\r\n    /**\r\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\r\n     * oldState that are not recognized, they are left untouched.\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Remove updated entries in cache\");\r\n        const accounts = oldState.Account ? this.mergeRemovalsDict<SerializedAccountEntity>(oldState.Account, newState.Account) : oldState.Account;\r\n        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\r\n        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\r\n        const idTokens = oldState.IdToken ? this.mergeRemovalsDict<SerializedIdTokenEntity>(oldState.IdToken, newState.IdToken) : oldState.IdToken;\r\n        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\r\n\r\n        return {\r\n            ...oldState,\r\n            Account: accounts,\r\n            AccessToken: accessTokens,\r\n            RefreshToken: refreshTokens,\r\n            IdToken: idTokens,\r\n            AppMetadata: appMetadata\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Helper to merge new cache with the old one\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    private mergeRemovalsDict<T>(oldState: Record<string, T>, newState?: Record<string, T>): Record<string, T> {\r\n        const finalState = { ...oldState };\r\n        Object.keys(oldState).forEach((oldKey) => {\r\n            if (!newState || !(newState.hasOwnProperty(oldKey))) {\r\n                delete finalState[oldKey];\r\n            }\r\n        });\r\n        return finalState;\r\n    }\r\n\r\n    /**\r\n     * Helper to overlay as a part of cache merge\r\n     * @param passedInCache - cache read from the blob\r\n     */\r\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\r\n        this.logger.verbose(\"Overlaying input cache with the default cache\");\r\n        return {\r\n            Account: {\r\n                ...defaultSerializedCache.Account,\r\n                ...passedInCache.Account,\r\n            },\r\n            IdToken: {\r\n                ...defaultSerializedCache.IdToken,\r\n                ...passedInCache.IdToken,\r\n            },\r\n            AccessToken: {\r\n                ...defaultSerializedCache.AccessToken,\r\n                ...passedInCache.AccessToken,\r\n            },\r\n            RefreshToken: {\r\n                ...defaultSerializedCache.RefreshToken,\r\n                ...passedInCache.RefreshToken,\r\n            },\r\n            AppMetadata: {\r\n                ...defaultSerializedCache.AppMetadata,\r\n                ...passedInCache.AppMetadata,\r\n            },\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AuthorizationCodeClient,\r\n    ClientConfiguration,\r\n    RefreshTokenClient,\r\n    AuthenticationResult,\r\n    Authority,\r\n    AuthorityFactory,\r\n    BaseAuthRequest,\r\n    SilentFlowClient,\r\n    Logger,\r\n    ServerTelemetryManager,\r\n    ServerTelemetryRequest,\r\n    CommonSilentFlowRequest,\r\n    CommonRefreshTokenRequest,\r\n    CommonAuthorizationCodeRequest,\r\n    CommonAuthorizationUrlRequest,\r\n    AuthenticationScheme,\r\n    ResponseMode,\r\n    AuthorityOptions,\r\n    OIDC_DEFAULT_SCOPES,\r\n    AzureRegionConfiguration\r\n} from \"@azure/msal-common\";\r\nimport { Configuration, buildAppConfiguration } from \"../config/Configuration\";\r\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\r\nimport { NodeStorage } from \"../cache/NodeStorage\";\r\nimport { Constants as NodeConstants, ApiId } from \"../utils/Constants\";\r\nimport { TokenCache } from \"../cache/TokenCache\";\r\nimport { ClientAssertion } from \"./ClientAssertion\";\r\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\r\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\r\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest\";\r\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest\";\r\nimport { version, name } from \"../packageMetadata\";\r\n\r\n/**\r\n * Base abstract class for all ClientApplications - public and confidential\r\n * @public\r\n */\r\nexport abstract class ClientApplication {\r\n\r\n    private readonly cryptoProvider: CryptoProvider;\r\n    private tokenCache: TokenCache;\r\n\r\n    /**\r\n     * Platform storage object\r\n     */\r\n    protected storage: NodeStorage;\r\n    /**\r\n     * Logger object to log the application flow\r\n     */\r\n    protected logger: Logger;\r\n    /**\r\n     * Platform configuration initialized by the application\r\n     */\r\n    protected config: Configuration;\r\n    /**\r\n     * Client assertion passed by the user for confidential client flows\r\n     */\r\n    protected clientAssertion: ClientAssertion;\r\n    /**\r\n     * Client secret passed by the user for confidential client flows\r\n     */\r\n    protected clientSecret: string;\r\n\r\n    /**\r\n     * Constructor for the ClientApplication\r\n     */\r\n    protected constructor(configuration: Configuration) {\r\n        this.config = buildAppConfiguration(configuration);\r\n        this.cryptoProvider = new CryptoProvider();\r\n        this.logger = new Logger(this.config.system!.loggerOptions!, name, version);\r\n        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);\r\n        this.tokenCache = new TokenCache(\r\n            this.storage,\r\n            this.logger,\r\n            this.config.cache!.cachePlugin\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request, letting the user input credentials and consent to the\r\n     * application. The URL targets the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * `acquireTokenByCode(AuthorizationCodeRequest)`.\r\n     */\r\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\r\n        this.logger.info(\"getAuthCodeUrl called\");\r\n        const validRequest: CommonAuthorizationUrlRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            responseMode: request.responseMode || ResponseMode.QUERY,\r\n            authenticationScheme: AuthenticationScheme.BEARER\r\n        };\r\n        \r\n        const authClientConfig = await this.buildOauthClientConfiguration(\r\n            validRequest.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const authorizationCodeClient = new AuthorizationCodeClient(\r\n            authClientConfig\r\n        );\r\n        return authorizationCodeClient.getAuthCodeUrl(validRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\r\n     * Authorization Code flow.\r\n     *\r\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\r\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\r\n     * AuthorizationCodeRequest are the same.\r\n     */\r\n    async acquireTokenByCode(request: AuthorizationCodeRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByCode called\");\r\n        const validRequest: CommonAuthorizationCodeRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            authenticationScheme: AuthenticationScheme.BEARER\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId!);\r\n        try {\r\n            const authClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                serverTelemetryManager\r\n            );\r\n            this.logger.verbose(\"Auth client config generated\");\r\n            const authorizationCodeClient = new AuthorizationCodeClient(\r\n                authClientConfig\r\n            );\r\n            return authorizationCodeClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\r\n     *\r\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\r\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\r\n     * handle the caching and refreshing of tokens automatically.\r\n     */\r\n    async acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByRefreshToken called\");\r\n        const validRequest: CommonRefreshTokenRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            authenticationScheme: AuthenticationScheme.BEARER\r\n        };\r\n\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);\r\n        try {\r\n            const refreshTokenClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                serverTelemetryManager\r\n            );\r\n            this.logger.verbose(\"Auth client config generated\");\r\n            const refreshTokenClient = new RefreshTokenClient(\r\n                refreshTokenClientConfig\r\n            );\r\n            return refreshTokenClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires a token silently when a user specifies the account the token is requested for.\r\n     *\r\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\r\n     * There is also an optional \"forceRefresh\" boolean the user can send to bypass the cache for access_token and id_token.\r\n     * In case the refresh_token is expired or not found, an error is thrown\r\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\r\n     */\r\n    async acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult | null> {\r\n        const validRequest: CommonSilentFlowRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            forceRefresh: request.forceRefresh || false\r\n        };\r\n\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);\r\n        try {\r\n            const silentFlowClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                serverTelemetryManager\r\n            );\r\n            const silentFlowClient = new SilentFlowClient(\r\n                silentFlowClientConfig\r\n            );\r\n            return silentFlowClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the token cache for the application.\r\n     */\r\n    getTokenCache(): TokenCache {\r\n        this.logger.info(\"getTokenCache called\");\r\n        return this.tokenCache;\r\n    }\r\n\r\n    /**\r\n     * Returns the logger instance\r\n     */\r\n    getLogger(): Logger {\r\n        return this.logger;\r\n    }\r\n\r\n    /**\r\n     * Replaces the default logger set in configurations with new Logger with new configurations\r\n     * @param logger - Logger instance\r\n     */\r\n    setLogger(logger: Logger): void {\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\r\n     * @param authority - user passed authority in configuration\r\n     * @param serverTelemetryManager - initializes servertelemetry if passed\r\n     */\r\n    protected async buildOauthClientConfiguration(authority: string, serverTelemetryManager?: ServerTelemetryManager, azureRegionConfiguration?: AzureRegionConfiguration): Promise<ClientConfiguration> {\r\n        this.logger.verbose(\"buildOauthClientConfiguration called\");\r\n        // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\r\n        this.logger.verbose(`building oauth client configuration with the authority: ${authority}`);\r\n\r\n        const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration);\r\n\r\n        return {\r\n            authOptions: {\r\n                clientId: this.config.auth.clientId,\r\n                authority: discoveredAuthority,\r\n                clientCapabilities: this.config.auth.clientCapabilities\r\n            },\r\n            loggerOptions: {\r\n                loggerCallback: this.config.system!.loggerOptions!\r\n                    .loggerCallback,\r\n                piiLoggingEnabled: this.config.system!.loggerOptions!\r\n                    .piiLoggingEnabled,\r\n            },\r\n            cryptoInterface: this.cryptoProvider,\r\n            networkInterface: this.config.system!.networkClient,\r\n            storageInterface: this.storage,\r\n            serverTelemetryManager: serverTelemetryManager,\r\n            clientCredentials: {\r\n                clientSecret: this.clientSecret,\r\n                clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : undefined,\r\n            },\r\n            libraryInfo: {\r\n                sku: NodeConstants.MSAL_SKU,\r\n                version: version,\r\n                cpu: process.arch || \"\",\r\n                os: process.platform || \"\",\r\n            },\r\n            persistencePlugin: this.config.cache!.cachePlugin,\r\n            serializableCache: this.tokenCache,\r\n        };\r\n    }\r\n\r\n    private getClientAssertion(authority: Authority): { assertion: string, assertionType: string } {\r\n        return {\r\n            assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),\r\n            assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates a request with the default scopes & generates a correlationId.\r\n     * @param authRequest - BaseAuthRequest for initialization\r\n     */\r\n    protected initializeBaseRequest(authRequest: Partial<BaseAuthRequest>): BaseAuthRequest {\r\n        this.logger.verbose(\"initializeRequestScopes called\");\r\n        // Default authenticationScheme to Bearer, log that POP isn't supported yet\r\n        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {\r\n            this.logger.verbose(\"Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request\");\r\n        }\r\n\r\n        authRequest.authenticationScheme = AuthenticationScheme.BEARER;\r\n\r\n        return {\r\n            ...authRequest,\r\n            scopes: [...((authRequest && authRequest.scopes) || []), ...OIDC_DEFAULT_SCOPES],\r\n            correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),\r\n            authority: authRequest.authority || this.config.auth.authority!\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Initializes the server telemetry payload\r\n     * @param apiId - Id for a specific request\r\n     * @param correlationId - GUID\r\n     * @param forceRefresh - boolean to indicate network call\r\n     */\r\n    protected initializeServerTelemetryManager(apiId: number, correlationId: string, forceRefresh?: boolean): ServerTelemetryManager {\r\n        const telemetryPayload: ServerTelemetryRequest = {\r\n            clientId: this.config.auth.clientId,\r\n            correlationId: correlationId,\r\n            apiId: apiId,\r\n            forceRefresh: forceRefresh || false\r\n        };\r\n\r\n        return new ServerTelemetryManager(telemetryPayload, this.storage);\r\n    }\r\n\r\n    /**\r\n     * Create authority instance. If authority not passed in request, default to authority set on the application\r\n     * object. If no authority set in application object, then default to common authority.\r\n     * @param authorityString - authority from user configuration\r\n     */\r\n    private async createAuthority(authorityString: string, azureRegionConfiguration?: AzureRegionConfiguration): Promise<Authority> {\r\n        this.logger.verbose(\"createAuthority called\");\r\n        const authorityOptions: AuthorityOptions = {\r\n            protocolMode: this.config.auth.protocolMode!,\r\n            knownAuthorities: this.config.auth.knownAuthorities!,\r\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata!,\r\n            authorityMetadata: this.config.auth.authorityMetadata!,\r\n            azureRegionConfiguration \r\n        };\r\n        return await AuthorityFactory.createDiscoveredInstance(authorityString, this.config.system!.networkClient!, this.storage, authorityOptions);\r\n    }\r\n}\r\n","/* eslint-disable header/header */\nexport const name = \"@azure/msal-node\";\nexport const version = \"1.1.0\";\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { sign } from \"jsonwebtoken\";\r\nimport { TimeUtils, ClientAuthError } from \"@azure/msal-common\";\r\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\r\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\r\nimport { JwtConstants } from \"../utils/Constants\";\r\n\r\n/**\r\n * Client assertion of type jwt-bearer used in confidential client flows\r\n * @public\r\n */\r\nexport class ClientAssertion {\r\n\r\n    private jwt: string;\r\n    private privateKey: string;\r\n    private thumbprint: string;\r\n    private expirationTime: number;\r\n    private issuer: string;\r\n    private jwtAudience: string;\r\n    private publicCertificate: Array<string>;\r\n\r\n    /**\r\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\r\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\r\n     */\r\n    public static fromAssertion(assertion: string): ClientAssertion {\r\n        const clientAssertion = new ClientAssertion();\r\n        clientAssertion.jwt = assertion;\r\n        return clientAssertion;\r\n    }\r\n\r\n    /**\r\n     * Initialize the ClientAssertion class from the certificate passed by the user\r\n     * @param thumbprint - identifier of a certificate\r\n     * @param privateKey - secret key\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\r\n    public static fromCertificate(thumbprint: string, privateKey: string, publicCertificate?: string): ClientAssertion {\r\n        const clientAssertion = new ClientAssertion();\r\n        clientAssertion.privateKey = privateKey;\r\n        clientAssertion.thumbprint = thumbprint;\r\n        if (publicCertificate) {\r\n            clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);\r\n        }\r\n        return clientAssertion;\r\n    }\r\n\r\n    /**\r\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\r\n     * @param cryptoProvider - library's crypto helper\r\n     * @param issuer - iss claim\r\n     * @param jwtAudience - aud claim\r\n     */\r\n    public getJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\r\n        // if assertion was created from certificate, check if jwt is expired and create new one.\r\n        if (this.privateKey && this.thumbprint) {\r\n\r\n            if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {\r\n                return this.jwt;\r\n            }\r\n\r\n            return this.createJwt(cryptoProvider, issuer, jwtAudience);\r\n        }\r\n\r\n        /*\r\n         * if assertion was created by caller, then we just append it. It is up to the caller to\r\n         * ensure that it contains necessary claims and that it is not expired.\r\n         */\r\n        if (this.jwt) {\r\n            return this.jwt;\r\n        }\r\n\r\n        throw ClientAuthError.createInvalidAssertionError();\r\n    }\r\n\r\n    /**\r\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\r\n     */\r\n    private createJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\r\n\r\n        this.issuer = issuer;\r\n        this.jwtAudience = jwtAudience;\r\n        const issuedAt = TimeUtils.nowSeconds();\r\n        this.expirationTime = issuedAt + 600;\r\n\r\n        const header = {\r\n            [JwtConstants.ALGORITHM]: JwtConstants.RSA_256,\r\n            [JwtConstants.X5T]: EncodingUtils.base64EncodeUrl(this.thumbprint, \"hex\")\r\n        };\r\n\r\n        if (this.publicCertificate) {\r\n            Object.assign(header, {\r\n                [JwtConstants.X5C]: this.publicCertificate\r\n            });\r\n        }\r\n\r\n        const payload = {\r\n            [JwtConstants.AUDIENCE]: this.jwtAudience,\r\n            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,\r\n            [JwtConstants.ISSUER]: this.issuer,\r\n            [JwtConstants.SUBJECT]: this.issuer,\r\n            [JwtConstants.NOT_BEFORE]: issuedAt,\r\n            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()\r\n        };\r\n\r\n        this.jwt = sign(payload, this.privateKey, { header: header });\r\n        return this.jwt;\r\n    }\r\n\r\n    /**\r\n     * Utility API to check expiration\r\n     */\r\n    private isExpired(): boolean {\r\n        return this.expirationTime < TimeUtils.nowSeconds();\r\n    }\r\n\r\n    /**\r\n     * Extracts the raw certs from a given certificate string and returns them in an array.\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\r\n    public static parseCertificate(publicCertificate: string): Array<string> {\r\n        /**\r\n         * This is regex to identify the certs in a given certificate string.\r\n         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\r\n         * The information in parens \"(.+?)\" is the capture group to represent the cert we want isolated.\r\n         * \".\" means any string character, \"+\" means match 1 or more times, and \"?\" means the shortest match.\r\n         * The \"g\" at the end of the regex means search the string globally, and the \"s\" enables the \".\" to match newlines.\r\n         */\r\n        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\\n(.+?)\\n-----END CERTIFICATE-----/gs;\r\n        const certs: string[] = [];\r\n\r\n        let matches;\r\n        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\r\n            // matches[1] represents the first parens capture group in the regex.\r\n            certs.push(matches[1].replace(/\\n/, \"\"));\r\n        }\r\n\r\n        return certs;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ClientApplication } from \"./ClientApplication\";\r\nimport { Configuration } from \"../config/Configuration\";\r\nimport { ClientAssertion } from \"./ClientAssertion\";\r\nimport { ApiId , REGION_ENVIRONMENT_VARIABLE } from \"../utils/Constants\";\r\nimport {\r\n    ClientCredentialClient,\r\n    OnBehalfOfClient,\r\n    CommonClientCredentialRequest,\r\n    CommonOnBehalfOfRequest,\r\n    AuthenticationResult,\r\n    StringUtils,\r\n    ClientAuthError,\r\n    AzureRegionConfiguration\r\n} from \"@azure/msal-common\";\r\nimport { IConfidentialClientApplication } from \"./IConfidentialClientApplication\";\r\nimport { OnBehalfOfRequest } from \"../request/OnBehalfOfRequest\";\r\nimport { ClientCredentialRequest } from \"../request/ClientCredentialRequest\";\r\n\r\n/**\r\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\r\n *  will configure application secrets, client certificates/assertions as applicable\r\n * @public\r\n */\r\nexport class ConfidentialClientApplication extends ClientApplication implements IConfidentialClientApplication{\r\n\r\n    /**\r\n     * Constructor for the ConfidentialClientApplication\r\n     *\r\n     * Required attributes in the Configuration object are:\r\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\r\n     * - authority: the authority URL for your application.\r\n     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\r\n     *\r\n     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\r\n     * Full B2C functionality will be available in this library in future versions.\r\n     *\r\n     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\r\n     */\r\n    constructor(configuration: Configuration) {\r\n        super(configuration);\r\n        this.setClientCredential(this.config);\r\n    }\r\n\r\n    /**\r\n     * Acquires tokens from the authority for the application (not for an end user).\r\n     */\r\n    public async acquireTokenByClientCredential(request: ClientCredentialRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByClientCredential called\");\r\n        const validRequest: CommonClientCredentialRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request)\r\n        };\r\n        const azureRegionConfiguration: AzureRegionConfiguration = {\r\n            azureRegion: validRequest.azureRegion,\r\n            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE] \r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);\r\n        try {\r\n            const clientCredentialConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                serverTelemetryManager,\r\n                azureRegionConfiguration,\r\n            );\r\n            this.logger.verbose(\"Auth client config generated\");\r\n            const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig);\r\n            return clientCredentialClient.acquireToken(validRequest);\r\n        } catch(e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires tokens from the authority for the application.\r\n     *\r\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\r\n     * representing an end user. The current app can use the token (oboAssertion) to request another\r\n     * token to access downstream web API, on behalf of that user.\r\n     *\r\n     * The current middle-tier app has no user interaction to obtain consent.\r\n     * See how to gain consent upfront for your middle-tier app from this article.\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\r\n     */\r\n    public async acquireTokenOnBehalfOf(request: OnBehalfOfRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenOnBehalfOf called\");\r\n        const validRequest: CommonOnBehalfOfRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request)\r\n        };\r\n        const clientCredentialConfig = await this.buildOauthClientConfiguration(\r\n            validRequest.authority\r\n        );\r\n        this.logger.verbose(\"Auth client config generated\");\r\n        const oboClient = new OnBehalfOfClient(clientCredentialConfig);\r\n        return oboClient.acquireToken(validRequest);\r\n    }\r\n\r\n    private setClientCredential(configuration: Configuration): void {\r\n\r\n        const clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret!);\r\n        const clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion!);\r\n        const certificate = configuration.auth.clientCertificate!;\r\n        const certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);\r\n\r\n        // Check that at most one credential is set on the application\r\n        if (\r\n            clientSecretNotEmpty && clientAssertionNotEmpty ||\r\n            clientAssertionNotEmpty && certificateNotEmpty ||\r\n            clientSecretNotEmpty && certificateNotEmpty) {\r\n            throw ClientAuthError.createInvalidCredentialError();\r\n        }\r\n\r\n        if (clientSecretNotEmpty) {\r\n            this.clientSecret = configuration.auth.clientSecret!;\r\n            return;\r\n        }\r\n\r\n        if (clientAssertionNotEmpty) {\r\n            this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion!);\r\n            return;\r\n        }\r\n\r\n        if (!certificateNotEmpty) {\r\n            throw ClientAuthError.createInvalidCredentialError();\r\n        } else {\r\n            this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, configuration.auth.clientCertificate?.x5c);\r\n        }\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ApiId } from \"../utils/Constants\";\r\nimport {\r\n    DeviceCodeClient,\r\n    AuthenticationResult,\r\n    CommonDeviceCodeRequest,\r\n    CommonUsernamePasswordRequest,\r\n    UsernamePasswordClient\r\n} from \"@azure/msal-common\";\r\nimport { Configuration } from \"../config/Configuration\";\r\nimport { ClientApplication } from \"./ClientApplication\";\r\nimport { IPublicClientApplication } from \"./IPublicClientApplication\";\r\nimport { DeviceCodeRequest } from \"../request/DeviceCodeRequest\";\r\nimport { UsernamePasswordRequest } from \"../request/UsernamePasswordRequest\";\r\n\r\n/**\r\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\r\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\r\n * @public\r\n */\r\nexport class PublicClientApplication extends ClientApplication implements IPublicClientApplication {\r\n    /**\r\n     * Important attributes in the Configuration object for auth are:\r\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\r\n     * - authority: the authority URL for your application.\r\n     *\r\n     * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n     * - If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * - If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * - To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\r\n     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\r\n     * construction.\r\n     *\r\n     * ADFS authorities are of the form https://\\{instance\\}/adfs.\r\n     */\r\n    constructor(configuration: Configuration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token from the authority using OAuth2.0 device code flow.\r\n     * This flow is designed for devices that do not have access to a browser or have input constraints.\r\n     * The authorization server issues a DeviceCode object with a verification code, an end-user code,\r\n     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\r\n     * instructed to use another device to navigate to the verification URI to input credentials.\r\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\r\n     * until the end-user completes input of credentials.\r\n     */\r\n    public async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByDeviceCode called\");\r\n        const validRequest: CommonDeviceCodeRequest = Object.assign(request, this.initializeBaseRequest(request));\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId!);\r\n        try {\r\n            const deviceCodeConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                serverTelemetryManager\r\n            );\r\n            this.logger.verbose(\"Auth client config generated\");\r\n            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\r\n            return deviceCodeClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\r\n     *\r\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\r\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\r\n     * Microsoft's documentation and recommendations are at:\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\r\n     *\r\n     * @param request - UsenamePasswordRequest\r\n     */\r\n    async acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByUsernamePassword called\");\r\n        const validRequest: CommonUsernamePasswordRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request)\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId!);\r\n        try {\r\n            const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                serverTelemetryManager\r\n            );\r\n            this.logger.verbose(\"Auth client config generated\");\r\n            const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);\r\n            return usernamePasswordClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n"],"names":["HttpMethod","CharSet","ApiId","HttpClient","url","options","request","method","GET","headers","validateStatus","response","axios","body","data","status","cancellationToken","POST","timeout","DEFAULT_AUTH_OPTIONS","clientId","authority","Constants","DEFAULT_AUTHORITY","clientSecret","clientAssertion","clientCertificate","thumbprint","privateKey","x5c","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","clientCapabilities","protocolMode","ProtocolMode","AAD","DEFAULT_CACHE_OPTIONS","DEFAULT_SYSTEM_OPTIONS","loggerOptions","loggerCallback","piiLoggingEnabled","logLevel","LogLevel","Info","networkClient","getNetworkClient","buildAppConfiguration","auth","cache","system","EncodingUtils","str","encoding","Buffer","from","toString","base64Encode","replace","base64Str","length","base64Decode","PkceGenerator","verifier","this","generateCodeVerifier","challenge","generateCodeChallengeFromVerifier","buffer","crypto","randomBytes","bufferToCVString","base64EncodeUrl","codeVerifier","sha256","createHash","update","digest","charArr","i","byteLength","push","join","CryptoProvider","constructor","pkceGenerator","createNewGuid","uuidv4","guid","test","generateGuid","input","generatePkceCodes","getPublicKeyThumbprint","Error","signJwt","Deserializer","jsonFile","StringUtils","isEmpty","JSON","parse","accounts","accountObjects","Object","keys","map","key","serializedAcc","mappedAcc","homeAccountId","home_account_id","environment","realm","localAccountId","local_account_id","username","authorityType","authority_type","name","clientInfo","client_info","lastModificationTime","last_modification_time","lastModificationApp","last_modification_app","account","AccountEntity","CacheManager","toObject","idTokens","idObjects","serializedIdT","mappedIdT","credentialType","credential_type","client_id","secret","idToken","IdTokenEntity","accessTokens","atObjects","serializedAT","mappedAT","target","cachedAt","cached_at","expiresOn","expires_on","extendedExpiresOn","extended_expires_on","refreshOn","refresh_on","keyId","key_id","tokenType","token_type","accessToken","AccessTokenEntity","refreshTokens","rtObjects","serializedRT","mappedRT","familyId","family_id","refreshToken","RefreshTokenEntity","appMetadata","appMetadataObjects","serializedAmdt","mappedAmd","amd","AppMetadataEntity","jsonCache","Account","deserializeAccounts","IdToken","deserializeIdTokens","AccessToken","deserializeAccessTokens","RefreshToken","deserializeRefreshTokens","AppMetadata","deserializeAppMetadata","Serializer","stringify","accCache","accountEntity","idTCache","idTEntity","atCache","atEntity","rtCache","rtEntity","amdtCache","amdtEntity","inMemCache","serializeAccounts","serializeIdTokens","serializeAccessTokens","serializeRefreshTokens","serializeAppMetadata","NodeStorage","logger","cryptoImpl","registerChangeEmitter","func","changeEmitters","emitChange","forEach","call","cacheToInMemoryCache","inMemoryCache","inMemoryCacheToCache","getCache","getInMemoryCache","verbose","setInMemoryCache","setCache","getItem","verbosePii","setItem","value","getAccount","accountKey","isAccountEntity","setAccount","generateAccountKey","getIdTokenCredential","idTokenKey","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","isAccessTokenEntity","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","isAppMetadataEntity","setAppMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetrykey","serverTelemetryEntity","ServerTelemetryEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetryKey","serverTelemetry","getAuthorityMetadata","authorityMetadataEntity","AuthorityMetadataEntity","isAuthorityMetadataEntity","getAuthorityMetadataKeys","getKeys","filter","isAuthorityMetadata","setAuthorityMetadata","metadata","getThrottlingCache","throttlingCacheKey","throttlingCache","ThrottlingEntity","isThrottlingEntity","setThrottlingCache","removeItem","result","containsKey","includes","clear","deserializeAllCache","deserializeJSONBlob","serializeAllCache","defaultSerializedCache","TokenCache","storage","cachePlugin","cacheHasChanged","handleChangeEvent","bind","persistence","hasChanged","serialize","finalState","cacheSnapshot","mergeState","deserialize","deserializedCache","overlayDefaults","getKVStore","cacheContext","TokenCacheContext","beforeCacheAccess","getAllAccounts","afterCacheAccess","allAccounts","accountObj","removeAccount","generateAccountCacheKey","oldState","currentState","stateAfterRemoval","mergeRemovals","mergeUpdates","newState","newKey","newValue","hasOwnProperty","newValueNotNull","newValueIsObject","newValueIsNotArray","Array","isArray","oldStateNotUndefinedOrNull","mergeRemovalsDict","oldKey","passedInCache","ClientApplication","configuration","config","cryptoProvider","Logger","tokenCache","info","validRequest","initializeBaseRequest","responseMode","ResponseMode","QUERY","authenticationScheme","AuthenticationScheme","BEARER","authClientConfig","buildOauthClientConfiguration","AuthorizationCodeClient","getAuthCodeUrl","serverTelemetryManager","initializeServerTelemetryManager","acquireTokenByCode","correlationId","acquireToken","e","cacheFailedRequest","acquireTokenByRefreshToken","refreshTokenClientConfig","RefreshTokenClient","forceRefresh","acquireTokenSilent","silentFlowClientConfig","SilentFlowClient","getTokenCache","getLogger","setLogger","azureRegionConfiguration","discoveredAuthority","createAuthority","authOptions","cryptoInterface","networkInterface","storageInterface","clientCredentials","getClientAssertion","undefined","libraryInfo","sku","version","cpu","process","arch","os","platform","persistencePlugin","serializableCache","assertion","getJwt","tokenEndpoint","assertionType","authRequest","POP","scopes","OIDC_DEFAULT_SCOPES","apiId","ServerTelemetryManager","authorityString","authorityOptions","AuthorityFactory","createDiscoveredInstance","ClientAssertion","jwt","publicCertificate","parseCertificate","issuer","jwtAudience","isExpired","createJwt","ClientAuthError","createInvalidAssertionError","issuedAt","TimeUtils","nowSeconds","expirationTime","header","assign","payload","sign","regexToFindCerts","certs","matches","exec","setClientCredential","azureRegion","environmentRegion","env","acquireTokenByClientCredential","skipCache","clientCredentialConfig","ClientCredentialClient","OnBehalfOfClient","clientSecretNotEmpty","clientAssertionNotEmpty","certificate","certificateNotEmpty","createInvalidCredentialError","fromAssertion","fromCertificate","_configuration$auth$c","acquireTokenByDeviceCode","deviceCodeConfig","DeviceCodeClient","acquireTokenByUsernamePassword","usernamePasswordClientConfig","UsernamePasswordClient"],"mappings":"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"}